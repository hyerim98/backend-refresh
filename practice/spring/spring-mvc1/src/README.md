# MVC1 - Section3: Servlet (V0)

> MVC 패턴 적용 전, 순수 서블릿 기반 구조  
> 이후 구조가 어떻게 발전하는지 비교하기 위한 기준 버전

---

## 1. V0 구조 개요

- 하나의 서블릿이 모든 역할을 수행
- 요청 처리 + 비즈니스 로직 + View 생성까지 직접 담당
- 관심사 분리 없음
- 웹 기술에 강하게 의존

---

## 2. V0에서 서블릿이 하는 일

하나의 서블릿 안에서 수행되는 작업:

1. 요청 파라미터 조회
2. 비즈니스 로직 실행
3. 응답 타입 설정 (Content-Type, 인코딩)
4. HTML을 직접 작성하여 응답 생성

> 즉, Controller + View 역할이 분리되지 않은 상태

---

## 3. 구조 흐름
Client 요청 -> Servlet -> 요청 파라미터 처리 -> 비즈니스 로직 실행 -> 
HTML 직접 생성 -> Response 반환

모든 책임이 하나의 클래스에 집중되어 있음

---

## 4. V0의 구조적 특징

### 4.1 관심사 분리 없음

- 요청 처리
- 비즈니스 로직
- 화면 생성

> 세 가지가 하나의 클래스에 섞여 있음

### 4.2 View를 자바 코드에서 직접 생성

- HTML을 문자열로 직접 작성
- 가독성 낮음
- 유지보수 어려움
- 화면 수정 시 자바 코드 수정 필요

### 4.3 웹 기술에 강하게 결합

- HttpServletRequest, HttpServletResponse
- 테스트가 어렵고, 웹 환경에 강하게 의존

### 4.4 중복 코드 발생 가능

- Content-Type 설정
- 인코딩 설정
- HTML 기본 구조 작성
- 기능이 늘어나면 서블릿이 비대해질 수 있음

---

## 5. V0의 한계

1. 유지보수 어려움
2. 확장성 낮음
3. 테스트 어려움
4. 코드 재사용 어려움
5. 역할 분리 실패

---

## 🔎 핵심 요약

V0는 **웹 애플리케이션을 프레임워크 없이 가장 기본 단계에서 직접 구현한 상태**  
이 기준으로 이후 구조 개선을 비교하면 이해가 훨씬 쉬움


# MVC1 - Section4: Servlet → JSP → MVC

> V0(순수 서블릿)의 한계를 해결해가는 과정

---

# 🔹 V1 - JSP 도입

## ✅ V0와 달라진 점

- View를 JSP로 분리
- Servlet에서 HTML 직접 작성 제거
- RequestDispatcher.forward() 사용

## 🔄 요청 흐름

Servlet → JSP → Response

## 👍 개선점

- HTML 작성 편리
- 가독성 향상
- View 관리 용이

## ❗ 한계점

- JSP에 자바 코드(scriptlet) 존재
- 여전히 Controller + Model 역할 혼재
- 완전한 MVC 아님

---

# 🔹 V2 - MVC 패턴 적용

## ✅ V1과 달라진 점

- Controller 역할 명확화
- Model 데이터를 request에 저장
- View는 화면 렌더링만 담당

## 🔄 요청 흐름

Controller
→ Model 생성
→ request.setAttribute()
→ View(JSP)

## 👍 개선점

- 관심사 분리
- 유지보수성 증가
- 구조적 확장 가능

## ❗ 한계점

- Controller마다 중복 코드 발생
- 공통 처리 어려움
- Front Controller 필요성 등장

---

# 📌 구조 발전 요약

V0 - 모든 걸 서블릿이 처리  
V1 - View 분리 (JSP)  
V2 - 역할 분리 (MVC 완성 형태)

---

# 💡 핵심 학습 포인트

- 관심사 분리의 필요성
- MVC가 왜 표준 구조가 되었는가
- 구조는 항상 "한계 → 개선"으로 발전한다


# 🛠 MVC1 - Section5 정리
## v1 → v4 코드 발전 과정 정리

> 목표: 점진적인 리팩토링을 통해 MVC 프레임워크 구조가 어떻게 발전했는지 이해하기

---

# 📌 v1 - Front Controller 도입

## ✅ 핵심 특징

- Front Controller 하나가 모든 요청을 받음
- 모든 컨트롤러는 동일한 인터페이스 구현
- 컨트롤러가 직접 request / response 사용
- 컨트롤러가 직접 View로 포워드

---

## 🔄 이전 구조(v0)와 달라진 점

- 공통 로직을 중앙에서 처리
- 중복 제거 시작
- URL 매핑을 Map 구조로 관리

---

## ❗ 한계점

- 컨트롤러가 서블릿 기술에 직접 의존
- Model 개념 없음
- View 처리 책임이 컨트롤러에 남아 있음
- 테스트하기 어려움

---

# 📌 v2 - View 분리

## ✅ 개선된 점

- View 객체 도입
- View 렌더링 책임을 Front Controller로 이동
- 컨트롤러는 View 객체만 반환

---

## 🔄 v1 대비 달라진 점

- View 처리 공통화
- 역할 분리 명확화
- 중복 포워드 코드 제거

---

## ❗ 한계점

- 여전히 request / response 직접 사용
- Model 개념이 명확하지 않음
- 서블릿 기술 종속

---

# 📌 v3 - ModelView 도입 (핵심 발전)

## ✅ 가장 큰 변화

- ModelView 객체 도입
- 컨트롤러는 request/response를 직접 사용하지 않음
- 파라미터를 Map 형태로 전달
- 논리적 viewName 반환

---

## 🔄 v2 대비 달라진 점

- 서블릿 기술 의존 제거
- ViewResolver 개념 도입
- 컨트롤러가 더 단순해짐
- 테스트 가능성 증가

---

## 📈 구조적 의미

- 진짜 MVC 패턴에 가까워짐
- 스프링 MVC 구조와 매우 유사

---

## ❗ 한계점

- 모든 컨트롤러가 동일한 인터페이스만 사용 가능
- 다른 방식의 컨트롤러 추가 불가능

---

# 📌 v4 - Model 분리 & 더 단순화

## ✅ 개선된 점

- ModelView 제거
- Model을 파라미터로 전달
- viewName만 반환

---

## 🔄 v3 대비 달라진 점

- 코드 간결화
- 컨트롤러 작성 편의성 증가
- 실무 코드 스타일과 유사

---

## 📈 구조적 의미

- 개발자가 작성하기 쉬운 형태로 개선
- 유지보수성 향상

---

# 📌 추가 발전 - HandlerAdapter 도입

## 🎯 도입 목적

- 서로 다른 타입의 컨트롤러를 함께 사용하기 위함
- 확장 가능 구조 설계

---

## ✅ 장점

- 새로운 컨트롤러 타입 추가 가능
- 기존 코드 수정 없이 확장 가능 (OCP)
- 유연한 구조 완성

---

# 📊 버전별 비교 요약

| 버전 | 핵심 키워드 | 서블릿 의존 | Model 분리 | View 처리 | 확장성 |
|------|-------------|-------------|------------|-----------|--------|
| v1 | Front Controller | O | X | 분산 | 낮음 |
| v2 | View 분리 | O | X | 중앙 처리 | 낮음 |
| v3 | ModelView | X | O | ViewResolver | 보통 |
| v4 | Model 파라미터 | X | O | ViewResolver | 높음 |

---

# 🔥 전체 흐름 한 줄 정리

v1 → 중복 제거 시작  
v2 → View 분리  
v3 → 서블릿 독립 + ModelView  
v4 → 더 단순하고 실용적인 구조

---

# 🎯 이번 Practice의 진짜 의미

- 프레임워크는 한 번에 완성되는 게 아니라 점진적으로 발전한다.
- 구조 개선은 "중복 제거 → 역할 분리 → 의존성 제거 → 확장성 확보" 순서로 진행된다.
- 우리가 만든 구조가 곧 스프링 MVC의 핵심 원리다.