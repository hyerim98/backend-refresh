# 객체지향 설계 예제

## 이 예제의 목적
- 객체지향 설계 원칙(섹션2)을 코드로 검증
- 스프링 DI로 발전하는 흐름 이해

---

## 설계 진화 히스토리

### v1. 순수 자바 기반 설계(섹션3)
👉 목적
- 객체지향 설계 원칙을 간단한 주문/할인 도메인으로 구현
- 다형성과 역할/구현 분리 체감

⚠️ 문제점
- ServiceImpl 소스를 보면 구현체에 직접 의존하고 있음
- 객체 생성과 연결 책임이 클라이언트에 있음

### v2. AppConfig 도입 (객체 생성 책임 분리)

👉 목표
- 객체 생성 책임과 사용 책임 분리
- DIP, OCP를 코드로 적용
- 설계 관점에서 객체 조립 개념 이해

⚙️ 변경 내용
- AppConfig 클래스 도입
- 구현체 생성 로직을 AppConfig로 이동
- 클라이언트(App)는 AppConfig를 통해 의존성 주입 받음

🔧 코드 변화
- App(MemberApp, OrderApp)에서 구현체 직접 생성(new) 제거
- AppConfig에서 각 역할에 맞는 구현체를 생성
- App(MemberApp, OrderApp)은 인터페이스 타입에만 의존

⚠️ 해결된 문제
- 구현체 변경 시 App(MemberApp, OrderApp) 코드 수정 불필요
- 객체 생성과 연결 책임이 한 곳(AppConfig)에 집중
- 역할과 구현이 명확히 분리됨

💡 설계 관점에서의 의미
- 고수준 모듈(App)이 저수준 모듈(구현체)에 의존하지 않음 (DIP)
- 기능 확장 시 기존 코드 수정 없이 구성 변경만으로 대응 가능 (OCP)
- 애플리케이션은 코드가 아니라 "설정"으로 조립된다는 개념 이해

### v3. 스프링 컨테이너 도입
- AppConfig는 더 이상 직접 호출되지 않음
- 설정 정보(@Configuration, @Bean)로만 사용
- 객체 생성과 조립은 스프링 컨테이너가 담당
- new 없이 빈을 조회해 사용할 수 있음
- 부모 타입으로 빈 조회시(ac.getBean()), 자식이 둘 이상 있으면(부모 타입으로 구현한 클래스가 둘 이상 있으면) 중복 오류가 발생한다 
-> 조회하고 싶은 빈 이름을 지정하면 된다

### v4. 싱글톤 컨테이너와 상태 관리
👉 왜 이 단계가 필요한가

스프링 컨테이너가 기본적으로 싱글톤을 사용하는 이유를
코드와 테스트로 검증하기 위한 단계

⚠️ 순수 DI 컨테이너의 문제점
- AppConfig를 직접 호출하면 요청마다 새로운 객체 생성
- 동일한 역할의 객체가 여러 개 만들어짐
- 메모리 낭비 및 관리 복잡도 증가

⚠️ 싱글톤 패턴의 한계
- static 인스턴스 방식
- private 생성자
- 테스트가 어려움
- DIP 위반 가능성

📌 스프링 싱글톤 컨테이너
- 컨테이너가 객체를 1개만 생성
- 요청 시 동일한 인스턴스 반환
- 개발자는 싱글톤을 직접 구현하지 않음

❗❗ 상태 유지(stateful)의 위험성
- 싱글톤 객체에 공유필드, 상태를 두면 문제 발생
- 여러 요청이 같은 인스턴스를 공유
- **해결**: 무상태(stateless) 설계

👉 **실습 코드**: practice/spring/spring-core-basic/src/test/java/hello/core/section6_singleton

